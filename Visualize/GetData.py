import numpy as np
import pandas as pd
import codecs

class geda:
    def __init__(self):
        self.name = geda

    def IntensityProfile(self,filename):
        file = codecs.open(filename, 'rb', 'utf-8', 'ignore')  # Open file, using codecs to uniform coding type
        line = file.readline()
        x = []
        y = []
        while line:
            data = line.split()
            data = list(map(float,data))
            x.append(data[0])
            y.append(data[1])
            line = file.readline()
        file.close()
        return [x,y]

    # This function is designed for extracting the data from the data files generated by the old KEITHLEY-4200.
    def KEITHLEY_4200_old(self, data_file, sheet_list):
        # 设置sheet_name=None，可以读取全部的sheet，返回字典，key为sheet名字，value为sheet表内容
        data = pd.read_excel(data_file, sheet_name=None)  # 利用pandas读取excel文件中的数据

        example_sheet = 'Data'  # 每一个老4200的数据文件都一定有Data这一页数据，可以利用这一页来取得4200中测试的项目
        # .columns.values.tolist()，这个命令可以得到数据表格的表头，也就是4200中测试的项目，如：Time, AI, BI ......
        title = data[example_sheet].columns.values.tolist()  # 数据的表头将以列表的形式储存
        num_charac = len(title)  # 测试的性能的个数（number of characteristics）
        num_cycle = len(sheet_list)  # 测试循环的次数即数据表格的个数

        extracted_data = [[] for i in range(num_cycle)]  # 按照测试循环的个数，将文件中的数据提取并分类到此表格中
        for i in sheet_list:
            sheet_index = sheet_list.index(i)  # 寻找字符串i在列表sheet_list中的索引，用于后续数据的分类
            sheet_data = data[i].values  # 将名字为变量i所指的字符串的那页（以下称sheet_i）提取出来的DataFrame数据转换成列表
            for j in range(num_charac):
                extracted_data[sheet_index].append(sheet_data[:, j])
                # 将sheet_i的数据按照项目名称重新整理到名为extracted_data的列表中
                # [[sheet1的数据], [sheet2的数据], [sheet3的数据], ...]
                # 而其中，[sheetX的数据] = [[测试项目1的数据], [测试项目2的数据], [测试项目3的数据], ...]

        return title, extracted_data

    # 这个函数可以对IV sweeping循环的测试结果进行分段，如：将0->5V->-5V->0的循环分为0->5V, 5V->0V, 0V->-5V, -5V->0V四段
    # IVsweep_data需以列表的形式输入，具体格式为[[测试项目1的数据], [测试项目2的数据], [测试项目3的数据], ...]
    def Segmenting_IVsweep(self,IVsweep_data,num_segment):
        num_total = len(IVsweep_data[0])  # IV扫描测试结果的总点数
        num_point = int(float(num_total-1)/float(num_segment))  # 每一段segment的点数
        # python进行除法时，记得转换为浮点数以免出错，然后还要转换为整型才能控制循环次数

        segmented_data = [[] for i in range(num_segment)]  # 分段后的数据储存的地方
        for i in range(num_segment):
            starting_index = i*num_point  # 切片起点
            end_index = (i+1)*num_point+1  # 切片终点（python的序号从零开始，而且是左闭右开，所以终点要取多一位以左右边界都被包括）
            for n in range(len(IVsweep_data)):  # 对IV sweep的测试项目进行历遍
                segmented_data[i].append(IVsweep_data[n][starting_index:end_index])
                # 根据前面计算的起点终点对每个项目进行切片并赋值到结果列表里面

        return num_segment, segmented_data


